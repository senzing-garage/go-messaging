# Code generated by jtd-codegen for Ruby v0.1.1

require 'json'
require 'time'

module SenzingTypeDef

  class SenzingMessage
    # Code for message.
    attr_accessor :code

    # A list of objects sent to the message generator.
    attr_accessor :details

    # Time duration reported by the message.
    attr_accessor :duration

    # A list of errors.  Usually a stack of errors.
    attr_accessor :errors

    # The unique identification of the message.
    attr_accessor :id

    # Log level.  Possible values: TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or
    # PANIC.
    attr_accessor :level

    # Location in the code identifying where the message was generated.
    attr_accessor :location

    # Reason for message.
    attr_accessor :reason

    # User-defined status of message.
    attr_accessor :status

    # Text representation of the message.
    attr_accessor :text

    # Time message was generated in RFC3339 format.
    attr_accessor :time

    def self.from_json_data(data)
      out = SenzingMessage.new
      out.code = SenzingTypeDef::from_json_data(String, data["code"])
      out.details = SenzingTypeDef::from_json_data(Details, data["details"])
      out.duration = SenzingTypeDef::from_json_data(Integer, data["duration"])
      out.errors = SenzingTypeDef::from_json_data(Errors, data["errors"])
      out.id = SenzingTypeDef::from_json_data(String, data["id"])
      out.level = SenzingTypeDef::from_json_data(String, data["level"])
      out.location = SenzingTypeDef::from_json_data(String, data["location"])
      out.reason = SenzingTypeDef::from_json_data(String, data["reason"])
      out.status = SenzingTypeDef::from_json_data(String, data["status"])
      out.text = SenzingTypeDef::from_json_data(String, data["text"])
      out.time = SenzingTypeDef::from_json_data(DateTime, data["time"])
      out
    end

    def to_json_data
      data = {}
      data["code"] = SenzingTypeDef::to_json_data(code)
      data["details"] = SenzingTypeDef::to_json_data(details)
      data["duration"] = SenzingTypeDef::to_json_data(duration)
      data["errors"] = SenzingTypeDef::to_json_data(errors)
      data["id"] = SenzingTypeDef::to_json_data(id)
      data["level"] = SenzingTypeDef::to_json_data(level)
      data["location"] = SenzingTypeDef::to_json_data(location)
      data["reason"] = SenzingTypeDef::to_json_data(reason)
      data["status"] = SenzingTypeDef::to_json_data(status)
      data["text"] = SenzingTypeDef::to_json_data(text)
      data["time"] = SenzingTypeDef::to_json_data(time)
      data
    end
  end

  # A detail published by the message generator.
  class Detail
    # The unique identifier of the detail.
    attr_accessor :key

    # The order in which the detail was given to the message generator.
    attr_accessor :position

    # Datatype of the value.
    attr_accessor :type

    # The value of the detail in string form.
    attr_accessor :value

    # The value of the detail if it differs from string form.
    attr_accessor :value_raw

    def self.from_json_data(data)
      out = Detail.new
      out.key = SenzingTypeDef::from_json_data(String, data["key"])
      out.position = SenzingTypeDef::from_json_data(Integer, data["position"])
      out.type = SenzingTypeDef::from_json_data(String, data["type"])
      out.value = SenzingTypeDef::from_json_data(String, data["value"])
      out.value_raw = SenzingTypeDef::from_json_data(Object, data["valueRaw"])
      out
    end

    def to_json_data
      data = {}
      data["key"] = SenzingTypeDef::to_json_data(key)
      data["position"] = SenzingTypeDef::to_json_data(position)
      data["type"] = SenzingTypeDef::to_json_data(type)
      data["value"] = SenzingTypeDef::to_json_data(value)
      data["valueRaw"] = SenzingTypeDef::to_json_data(value_raw)
      data
    end
  end

  # A list of details.
  class Details
    attr_accessor :value

    def self.from_json_data(data)
      out = Details.new
      out.value = SenzingTypeDef.from_json_data(Array[Detail], data)
      out
    end

    def to_json_data
      SenzingTypeDef.to_json_data(value)
    end
  end

  # The text representation of the error.
  class Error
    attr_accessor :value

    def self.from_json_data(data)
      out = Error.new
      out.value = SenzingTypeDef.from_json_data(String, data)
      out
    end

    def to_json_data
      SenzingTypeDef.to_json_data(value)
    end
  end

  # A list of errors.  Usually a stack of errors.
  class Errors
    attr_accessor :value

    def self.from_json_data(data)
      out = Errors.new
      out.value = SenzingTypeDef.from_json_data(Array[Error], data)
      out
    end

    def to_json_data
      SenzingTypeDef.to_json_data(value)
    end
  end

  private

  def self.from_json_data(type, data)
    if data.nil? || [Object, TrueClass, Integer, Float, String].include?(type)
      data
    elsif type == DateTime
      DateTime.rfc3339(data)
    elsif type.is_a?(Array)
      data.map { |elem| from_json_data(type.first, elem) }
    elsif type.is_a?(Hash)
      data.transform_values { |elem| from_json_data(type.values.first, elem) }
    else
      type.from_json_data(data)
    end
  end

  def self.to_json_data(data)
    if data.nil? || [TrueClass, FalseClass, Integer, Float, String].include?(data.class)
      data
    elsif data.is_a?(DateTime)
      data.rfc3339
    elsif data.is_a?(Array)
      data.map { |elem| to_json_data(elem) }
    elsif data.is_a?(Hash)
      data.transform_values { |elem| to_json_data(elem) }
    else
      data.to_json_data
    end
  end
end
