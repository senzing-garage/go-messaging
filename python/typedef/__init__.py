# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Union, get_args, get_origin


@dataclass
class SenzingMessage:
    code: 'str'
    """
    Code for message.
    """

    details: 'Details'
    """
    A list of objects sent to the message generator.
    """

    duration: 'int'
    """
    Time duration reported by the message.
    """

    errors: 'Errors'
    """
    A list of errors.  Usually a stack of errors.
    """

    id: 'str'
    """
    The unique identification of the message.
    """

    level: 'str'
    """
    Log level.  Possible values: TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or
    PANIC.
    """

    location: 'str'
    """
    Location in the code identifying where the message was generated.
    """

    reason: 'str'
    """
    Reason for message.
    """

    status: 'str'
    """
    User-defined status of message.
    """

    text: 'str'
    """
    Text representation of the message.
    """

    time: 'datetime'
    """
    Time message was generated in RFC3339 format.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SenzingMessage':
        return cls(
            _from_json_data(str, data.get("code")),
            _from_json_data(Details, data.get("details")),
            _from_json_data(int, data.get("duration")),
            _from_json_data(Errors, data.get("errors")),
            _from_json_data(str, data.get("id")),
            _from_json_data(str, data.get("level")),
            _from_json_data(str, data.get("location")),
            _from_json_data(str, data.get("reason")),
            _from_json_data(str, data.get("status")),
            _from_json_data(str, data.get("text")),
            _from_json_data(datetime, data.get("time")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["code"] = _to_json_data(self.code)
        data["details"] = _to_json_data(self.details)
        data["duration"] = _to_json_data(self.duration)
        data["errors"] = _to_json_data(self.errors)
        data["id"] = _to_json_data(self.id)
        data["level"] = _to_json_data(self.level)
        data["location"] = _to_json_data(self.location)
        data["reason"] = _to_json_data(self.reason)
        data["status"] = _to_json_data(self.status)
        data["text"] = _to_json_data(self.text)
        data["time"] = _to_json_data(self.time)
        return data

@dataclass
class Detail:
    """
    A detail published by the message generator.
    """

    key: 'str'
    """
    The unique identifier of the detail.
    """

    position: 'int'
    """
    The order in which the detail was given to the message generator.
    """

    type: 'str'
    """
    Datatype of the value.
    """

    value: 'str'
    """
    The value of the detail in string form.
    """

    value_raw: 'Any'
    """
    The value of the detail if it differs from string form.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Detail':
        return cls(
            _from_json_data(str, data.get("key")),
            _from_json_data(int, data.get("position")),
            _from_json_data(str, data.get("type")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Any, data.get("valueRaw")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["key"] = _to_json_data(self.key)
        data["position"] = _to_json_data(self.position)
        data["type"] = _to_json_data(self.type)
        data["value"] = _to_json_data(self.value)
        data["valueRaw"] = _to_json_data(self.value_raw)
        return data

@dataclass
class Details:
    """
    A list of details.
    """

    value: 'List[Detail]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Details':
        return cls(_from_json_data(List[Detail], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Error:
    """
    The text representation of the error.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Error':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Errors:
    """
    A list of errors.  Usually a stack of errors.
    """

    value: 'List[Error]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Errors':
        return cls(_from_json_data(List[Error], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
